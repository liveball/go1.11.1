算法：

排序：各种排序算法，时间复杂度，是否稳定

协议：

1. http
2. tcp
   * 三次握手
   * 四次挥手
   * 大量TIME_WAIT如何处理
   * 滑动窗口
3. Udp

缓存 redis：

* 数据结构及使用场景
* RDB和AOF
* 主从同步
* 集群
* 过期键处理
* 6种淘汰策略
* 缓存与数据库一致性
* 分布式锁
* 缓存击穿
* 缓存雪崩
* 热点KEY处理

数据库 mysql:

* B树定义，性质 （可能涉及平衡二叉树，红黑树）
* 聚簇索引和非聚簇索引
* ACID
* 事务隔离级别
* redo log 和 undo log
* 索引优化
* 数据库锁 MVVC 行锁 间隙锁 next-key锁
* 主备同步
* 读写分离
* 分库分表



### 协议

##### TCP

三次握手：客户端`connect`方发送`syn`，服务端发送`syn+ack`，客户端发送`ack`。

三次握手的原因：如果服务端收到`syn`就发送`syn+ack`然后连接就建立起来，那么可能由于网络原因，客户端没有及时收到服务器发送的`syn+ack`，超时后重发`syn`，那么服务端会建立另外一条连接，显然是不合理的。如果有第三次握手，服务端只有等待客户端确认发送`ack`后才建立连接，可以避免这种情况。

四次挥手：A在没有数据需要发送给B之后，关闭连接，发送FIN，进入FIN-WAIT-1状态，B收到FIN后，对此报文进行确认，进入CLOSE_WAIT状态，A收到确认报文后进入FIN-WAIT-2状态。当B关闭连接时，发送FIN，进入LAST-ACK状态，A对此报文进行确认，发送ACK，进入TIME-WAIT状态（等待2MSL后进入CLOSED状态）。B收到确认后进入CLOSED状态

四次挥手的原因：TCP是全双工连接，连接双方都可以单独关闭写，因此可以单独的发送FIN报文，另外需要对FIN报文进行确认发送ACK，因此需要四次挥手。

主动关闭连接的一方在进入TIME_WAIT状态时等待2MSL后才进入CLOSED状态的原因：

* 当由于网络原因，发送的ACK对端没有收到时，可以在此期间重传ACK报文，以确保对端能正常关闭连接
* 2MSL可以确保属于该连接的所有报文在网络中消失，不会影响下一个新的连接。

### 缓存 Redis

#####常用数据结构及应用场景

常用数据结构：字符串，链表，哈希，集合，有序集合

字符串：数字，二进制串如图片，字符串

链表：用于分页列表，消息队列

哈希：存储对象信息，可单独获取/更新字段

集合：需要去重、判断是否存在某元素，求交集，并集，差集场景

有序集合：在集合的基础上，增加了有序这个特性。可用于排行榜场景

##### RDB和AOF

RDB是Redis在指定间隔内生成的某个时间点上的数据快照。优势：紧凑二进制文件，常用于数据备份，数据恢复时性能要高于AOF。快照生成过程，fork出一个子进程，然后对当前数据集生成二进制快照文件。劣势：RDB生成的频率一般不会很频繁，因此在备份周期内若宕机，则此期间的数据将丢失。当数据集非常大的时候，fork的开销也会非常大，可能会导致主线程阻塞。

AOF将所有写操作都追加到文件尾，在恢复时，对命令进行重放，当AOF不断写入，文件过大时，会对AOF进行重写，Redis fork一个子进程重建AOF文件，此期间写入命令存入缓冲区，当重建完成时，再将缓冲区追加到文件尾部。AOF优势：在数据持久化上相比RDB更加安全，有三种fsync策略：无fsync（依赖操作系统刷盘），每秒fsync（默认策略，最多丢失一秒钟的数据，同时性能也很好），每个写命令都fsync（不会丢失数据，但是性能很差）。AOF文件增长过大时，会后台进行重写，用最少的命令构建数据集。缺点：AOF文件比RDB文件大。在数据恢复时比RDB慢。

（SAVE和BGSAVE区别：都是生成数据快照的命令。但是SAVE是在主线程中执行，因此主线程在此期间无法响应其他请求，禁止在使用。BGSAVE是使用后台线程生成快照，主线程依旧可以响应请求）

#####主从同步：

主要机制：

1. 当主节点与从节点正常通信时，主节点将操作命令流发送给从节点，从节点执行这些命令从而保持与主节点数据同步（包括客户端写命令，键超时或者淘汰等改变数据集的操作）
2. 当从节点与主节点断开连接时，从节点自动重连，并尝试进行部分同步：获取在断开连接期间未收到的命令流。
3. 当断开时间过长，无法进行部分同步时，从节点会要求进行全量同步。此过程开销较大，主节点会生成当前数据集的快照发送给从节点，从节点利用快照恢复数据，最后主节点开始发送命令流给从节点。

Redis默认使用异步复制，从节点周期性异步的对收到的数据进行确认，主节点不会每次都等待从节点执行命令，但是主节点知道从节点已经处理了哪些命令。同步复制可以使用`WAIT`命令，该命令确保有足够数量的命令在其他从节点中，但是无法确认这些命令是否都在从节点中成功的执行完毕，因此还是有可能在故障时丢失数据。

##### 过期键处理

定期删除+惰性删除：每隔100MS扫描一部分设置了过期时间的键，如果过期就删除，如果过期的样本超过25%，则继续取样删除，当访问到过期的键时，删除键，返回空。

##### 淘汰策略

分别针对所有键和设置了过期时间的键：随机删除，LRU。设置了过期时间的键TTL删除，不删除六种策略

redis的LRU算法是一种近似LRU的算法，开销较严格LRU算法小，但是效果几乎一致。

触发：当redis收到命令，若此命令会导致内存大小超过`maxmemory`配置值，则执行淘汰策略

Redis 4.0引入LFU，通过统计访问频率，删除频率最低的键

##### 缓存穿透

一般是指缓存和数据库中都没有数据，而用户不断发起请求，如发起id=-1的数据或者id特别大但是不存在的数据，这时的用户很可能是攻击者，导致数据库压力过大。

解决方案：

* 接口层增加校验，如用户鉴权校验，id做基础校验，如id<=0 的请求直接拦截
* 从缓存没有获取到数据，从数据库也没有获取到数据，这时可以将key-value 设置为key-null,
缓存有效时间可以设置短一点，如30s（设置过长会导致正常情况也无法使用），这样可以防止攻击用户反复使用同一个id进行攻击。

##### 缓存击穿

一般是指缓存中没有但是数据库中有的数据（一般由于缓存过期），
这时由于并发用户过多，大量请求在缓存中无法找到值，从而导致大量请求流向数据库

解决方案：

* 过滤非法参数
* 对不存在的数据缓存一个空数据，并设置较短的过期时间
* 设置热点数据永不过期
* 加互斥锁

##### 缓存雪崩

由于Redis启动时没有数据、键同一时间大面积失效或者Redis宕机，导致大量请求流向数据库

解决方案：

* 数据预热，将可能被用到的数据提前加载到Redis中
* 合理设置键的过期时间，加上一定的随机值，避免同时失效
* 使用Sentinal、cluster、replication提升redis高可用性
* 应用层使用熔断、降级策略，避免大量请求流向数据库，导致整个服务不可用，部分可用总比不可用好。

##### 缓存与数据库一致性

读：先读缓存，若缓存中有值直接返回，否则读数据库，更新缓存，然后返回

写：先写数据库，然后删除缓存，这里可能删除失败（使用其他异步方式重试删除，如消息队列，binlog订阅等，或者加失效时间，最终一致性）





### 数据库 MySQL

##### B树

m阶B树定义：

* 每个节点最多有m个孩子
* 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。
* 若根节点不是叶子节点，则至少有2个孩子
* 所有叶子节点都在同一层，且不包含其它关键字信息
* 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）
* 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1
* ki(i=1,…n)为关键字，且关键字升序排序
* Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B+树：

* 有k个子节点的节点包含k个关键字
* 非页节点仅具有索引作用，跟记录有关的信息均放在叶节点中
* 数的所有叶节点构成有序链表，方便范围遍历

B+树相比B树的优势：

* IO次数更少，B+树内部节点上不包含数据信息，同样大小的空间能够放入更多的关键字，数据存放紧密，具有更好的空间局部性。叶节点上保存有数据，可以直接读取。
* 遍历和范围查询更加快速

B树优势：B树内部节点保存有关联的数据信息，不必遍历到叶节点就可以找到的。

红黑树定义：

* 节点是红色或者黑色
* 根节点是黑色
* 每个叶节点的两个子节点（空）都是黑色的
* 红色节点的子节点是黑色的
* 任意节点到其每个叶节点的所有路径都包含相同个数的黑节点

红黑树降低了对平衡的要求，从而减少插入，删除时需要的旋转，最坏情况下，最长路径是最短路径的2倍。

##### 聚簇索引和非聚簇索引

InnoDB中只有主键使用聚簇索引，如果表定义中没有定义主键，则第一个unique索引被认为是主键，否则自动生成隐式主键，其他索引均为非聚簇索引。

聚簇索引叶节点上直接存储数据行，而非聚簇索引叶节点上存储的是主键，因此通过非聚簇索引查询，查询到叶节点后，获取主键，需要回表再去聚簇索引上用主键查询一遍（非覆盖索引场景）

聚簇索引优点：

* 叶节点直接存储数据行，查询效率高
* 对聚簇索引范围查询效率高

缺点：

* 聚簇索引在插入和更新主键时，可能导致页分裂
* 插入性能依赖插入顺序，按主键顺序插入效率最高，否则在批量插入后，最好使用`optimize table`重组表
* 全表扫描时，如果逻辑上相邻的叶节点，物理上相隔很远，会导致IO消耗高

##### 事务隔离级别

1. Read Uncommitted（读未提交）

   事务可能读到其他事务还未提交的数据，可能引起脏读，幻读。事务在读时候不会加锁，修改时会加排它锁。

2. Read Committed (读已提交)

   事务之间可以读到已提交的数据，可能引起不可重复读，幻读。读取数据时，通过MVCC获取当前数据的最新快照，不加锁。

   不可重复读: 事务A读取数据D，事务B修改数据D并提交完成事务，事务A再读数据D，前后两次读相同的数据，结果不一致。（根本原因是每次select时都生成最新的数据快照）

   幻读：事务A读取数据范围R，事务B在数据范围R内插入一条数据/删除一条数据，事务A再读取数据范围R，前后两次读取结果不一致。

3. Repeatable Read（可重复读）

   一次事务只在第一次`select`时生成数据快照，后续`select`都在此快照上进行，从而实现可重复读

   由于MVCC只对读操作有效，对写操作无效，从而会导致幻读：

   事务A：

   1. select * from user where age = 20;
   2. update user set foo=bar where age = 20;
   3. select * from user where age = 20;

   假设事务B在事务A执行完语句`1`之后，插入了`age=20`的10条数据，这20条数据对于事务A的第二条语句是可见的，语句`2`操作完后，这些数据对于事务A就可见，结果语句`3`会读到比语句`1`多出来的新插入的10条数据

4. Serialisable (串行化)

   该级别下自动将`select`转化为`select ... lock in share mode`，对同一数据的读写全被编程互斥，也就是说所有涉及到相同数据的事务都会串行执行，不会出现幻读，但是大大降低事务并发性。

   

*查看表的加锁情况: select \* from information_schema.INNODB_LOCKS;*

*事务状态 select \* from information_schema.INNODB_TRX;*

#####MVCC和锁

MVCC: 多版本并发控制，当读取数据时，若被其他事务使用排它锁锁住，可以通过读取历史版本，从而可避免互斥等待，InnoDB使用undo日志构造历史版本（undo日志？）

共享锁(S锁)：若事务对数据加S锁，则其他事务只能对数据再加S锁，在锁释放前，其他事务不能修改数据

排它锁(X锁): 若事务对数据加X锁，则只有该事务能访问此数据。

行锁(Record Lock)：只能是加在**索引**上的锁，eg select * from foo where id=2 for update

间隙锁(Gap Locks)：锁住两个索引之间的区域，开区间。eg select * from foo where id > 2 and id < 10 for update

Next-Key Locks：行锁+间隙锁形成闭区间，eg select * from foo where id >= 2 and id <= 10

如果选择的列上没有索引，则无法在索引上加锁，直接对整个表加锁

何时加锁：`insert`，`update`，`delete`都会加上排它锁。`select`默认不加锁，`select .. lock in share mode`加共享锁，`select .. for update`加排它锁

##### 索引优化

- 最左前缀匹配原则
- 选择性高的列作为索引或者放在联合索引的靠左侧位置
- 索引不参与计算
- 尽量扩展索引，不要新建索引

索引选择性：不重复的索引值和记录总数的比值。

覆盖索引：索引包含需要查询的字段

先分析业务中涉及到此表的所有sql语句，综合分析，结合建立索引的原则，使用最少的索引，尽量覆盖所有语句

