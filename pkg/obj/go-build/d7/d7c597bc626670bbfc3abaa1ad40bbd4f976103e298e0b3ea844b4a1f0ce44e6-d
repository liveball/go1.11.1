// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/fpf/Downloads/go1.11.1/misc/cgo/test/issue6612.go:1:1
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// golang.org/issue/6612
// Test new scheme for deciding whether C.name is an expression, type, constant.
// Clang silences some warnings when the name is a #defined macro, so test those too
// (even though we now use errors exclusively, not warnings).

package cgotest

/*
void myfunc(void) {}
int myvar = 5;
const char *mytext = "abcdef";
typedef int mytype;
enum {
	myenum = 1234,
};

#define myfunc_def myfunc
#define myvar_def myvar
#define mytext_def mytext
#define mytype_def mytype
#define myenum_def myenum
#define myint_def 12345
#define myfloat_def 1.5
#define mystring_def "hello"
*/
import _ "unsafe"

import "testing"

func testNaming(t *testing.T) {
	(_Cfunc_myfunc)()
	(_Cfunc_myfunc_def)()
	if v := (*_Cvar_myvar); v != 5 {
		t.Errorf("C.myvar = %d, want 5", v)
	}
	if v := (_Cmacro_myvar_def()); v != 5 {
		t.Errorf("C.myvar_def = %d, want 5", v)
	}
	if s := (_Cfunc_GoString)((*_Cvar_mytext)); s != "abcdef" {
		t.Errorf("C.mytext = %q, want %q", s, "abcdef")
	}
	if s := (_Cfunc_GoString)((_Cmacro_mytext_def())); s != "abcdef" {
		t.Errorf("C.mytext_def = %q, want %q", s, "abcdef")
	}
	if c := (_Ciconst_myenum); c != 1234 {
		t.Errorf("C.myenum = %v, want 1234", c)
	}
	if c := (_Ciconst_myenum_def); c != 1234 {
		t.Errorf("C.myenum_def = %v, want 1234", c)
	}
	{
		const c = (_Ciconst_myenum)
		if c != 1234 {
			t.Errorf("C.myenum as const = %v, want 1234", c)
		}
	}
	{
		const c = (_Ciconst_myenum_def)
		if c != 1234 {
			t.Errorf("C.myenum as const = %v, want 1234", c)
		}
	}
	if c := (_Ciconst_myint_def); c != 12345 {
		t.Errorf("C.myint_def = %v, want 12345", c)
	}
	{
		const c = (_Ciconst_myint_def)
		if c != 12345 {
			t.Errorf("C.myint as const = %v, want 12345", c)
		}
	}

	if c := (_Cfconst_myfloat_def); c != 1.5 {
		t.Errorf("C.myint_def = %v, want 1.5", c)
	}
	{
		const c = (_Cfconst_myfloat_def)
		if c != 1.5 {
			t.Errorf("C.myint as const = %v, want 1.5", c)
		}
	}

	if s := (_Csconst_mystring_def); s != "hello" {
		t.Errorf("C.mystring_def = %q, want %q", s, "hello")
	}
}
