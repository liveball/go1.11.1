package channel

type PayloadCollection struct {
	WindowsVersion string    `json:"version"`
	Token          string    `json:"token"`
	Payloads       []Payload `json:"data"`
}

type Payload struct {
	// [redacted]
}

// func (p *Payload) UploadToS3() error {
// 	// the storageFolder method ensures that there are no name collision in
// 	// case we get same timestamp in the key name
// 	storage_path := fmt.Sprintf("%v/%v", p.storageFolder, time.Now().UnixNano())

// 	bucket := S3Bucket

// 	b := new(bytes.Buffer)
// 	encodeErr := json.NewEncoder(b).Encode(payload)
// 	if encodeErr != nil {
// 		return encodeErr
// 	}

// 	// Everything we post to the S3 bucket should be marked 'private'
// 	var acl = s3.Private
// 	var contentType = "application/octet-stream"

// 	return bucket.PutReader(storage_path, b, int64(b.Len()), contentType, acl, s3.Options{})
// }

// func payloadHandler(w http.ResponseWriter, r *http.Request) {

// 	if r.Method != "POST" {
// 		w.WriteHeader(http.StatusMethodNotAllowed)
// 		return
// 	}

// 	// Read the body into a string for json decoding
// 	var content = &PayloadCollection{}
// 	err := json.NewDecoder(io.LimitReader(r.Body, MaxLength)).Decode(&content)
// 	if err != nil {
// 		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
// 		w.WriteHeader(http.StatusBadRequest)
// 		return
// 	}

// 	// Go through each payload and queue items individually to be posted to S3
// 	for _, payload := range content.Payloads {
// 		go payload.UploadToS3() // <----- DON'T DO THIS
// 	}

// 	w.WriteHeader(http.StatusOK)
// }
